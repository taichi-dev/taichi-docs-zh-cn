# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2020, Taichi Developers
# This file is distributed under the same license as the taichi package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2020.
#
msgid ""
msgstr ""
"Project-Id-Version: taichi 0.6.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-06-14 12:50+0800\n"
"PO-Revision-Date: 2020-06-21 14:31+0800\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.8.0\n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_CN\n"
"X-Generator: Poedit 2.3.1\n"

#: ../../export_results.rst:2
msgid "Export your results"
msgstr "导出结果"

#: ../../export_results.rst:3
msgid ""
"Taichi has functions that help you **export visual results to images or "
"videos**. This tutorial demonstrates how to use them step by step."
msgstr ""
"Taichi 提供的函数可以帮助你以 **图像或视频的形式导出可视化结果** 。本节文档将"
"逐步演示如何使用它们。"

#: ../../export_results.rst:6
msgid "Export images"
msgstr "导出图像"

#: ../../export_results.rst:8
msgid "There are two ways to export visual results of your program to images."
msgstr "这里有两种方法可以将程序的可视化结果导出为图像。"

#: ../../export_results.rst:9
msgid "The first and easier way is to make use of ``ti.GUI``."
msgstr "第一种也是较简单的方式是使用 ``ti.GUI``."

#: ../../export_results.rst:10
msgid "The second way is to call some Taichi functions such as ``ti.imwrite``."
msgstr "第二种方式会调用一系列相关 Taichi 函数，比如 ``ti.imwrite``."

#: ../../export_results.rst:13
msgid "Export images using ``ti.GUI.show``"
msgstr "通过 ``ti.GUI.show`` 导出图像"

#: ../../export_results.rst:15
msgid ""
"``ti.GUI.show(filename)`` can not only display the GUI canvas on your "
"screen, but also save the image to your specified ``filename``."
msgstr ""
"``ti.GUI.show(文件名)`` 不仅可以在屏幕上显示 GUI 画布，还可以将图像保存到指定"
"的 ``文件名`` 中。"

#: ../../export_results.rst:16
msgid ""
"Note that the format of the image is fully determined by the suffix of "
"``filename``."
msgstr "请注意，图像的格式完全由 ``文件名`` 里的后缀所决定。"

#: ../../export_results.rst:17
msgid "Taichi now supports saving to ``png``, ``jpg``, and ``bmp`` formats."
msgstr "Taichi 现在支持将图片保存为 ``png``, ``jpg``, 和 ``bmp`` 格式。"

#: ../../export_results.rst:18
msgid "We recommend using ``png`` format. For example:"
msgstr "我们建议使用 ``png`` 格式。例如:"

#: ../../export_results.rst:20
msgid ""
"import taichi as ti\n"
"import os\n"
"\n"
"ti.init()\n"
"\n"
"pixels = ti.var(ti.u8, shape=(512, 512, 3))\n"
"\n"
"@ti.kernel\n"
"def paint():\n"
"    for i, j, k in pixels:\n"
"        pixels[i, j, k] = ti.random() * 255\n"
"\n"
"iterations = 1000\n"
"gui = ti.GUI(\"Random pixels\", res=512)\n"
"\n"
"# mainloop\n"
"for i in range(iterations):\n"
"    paint()\n"
"    gui.set_image(pixels)\n"
"\n"
"    filename = f'frame_{i:05d}.png'   # create filename with suffix png\n"
"    print(f'Frame {i} is recorded in {filename}')\n"
"    gui.show(filename)  # export and show in GUI"
msgstr ""
"import taichi as ti\n"
"import os\n"
"\n"
"ti.init()\n"
"\n"
"pixels = ti.var(ti.u8, shape=(512, 512, 3))\n"
"\n"
"@ti.kernel\n"
"def paint():\n"
"    for i, j, k in pixels:\n"
"        pixels[i, j, k] = ti.random() * 255\n"
"\n"
"iterations = 1000\n"
"gui = ti.GUI(''Random pixels'', res=512)\n"
"\n"
"# mainloop\n"
"for i in range(iterations):\n"
"    paint()\n"
"    gui.set_image(pixels)\n"
"\n"
"    filename = f'frame_{i:05d}.png'   # 创建带有 png 后缀的文件名\n"
"    print(f'Frame {i} is recorded in {filename}')\n"
"    gui.show(filename)  # 导出并显示在 GUI 中"

#: ../../export_results.rst:46
msgid ""
"After running the code above, you will get a series of images in the current "
"folder."
msgstr "运行上述代码后，你将在当前文件夹中获得一系列 png 图像。"

#: ../../export_results.rst:49
msgid "Export images using ``ti.imwrite``"
msgstr "通过  ``ti.imwrite`` 导出图像"

#: ../../export_results.rst:50
msgid ""
"To save images without invoking ``ti.GUI.show(filename)``, use ``ti."
"imwrite(filename)``. For example:"
msgstr ""
"如果不想通过调用 ``ti.GUI.show(文件名)`` 保存图像的话，可以使用 ``ti."
"imwrite(文件名)``。例如:"

#: ../../export_results.rst:52
msgid ""
"import taichi as ti\n"
"\n"
"ti.init()\n"
"\n"
"pixels = ti.var(ti.u8, shape=(512, 512, 3))\n"
"\n"
"@ti.kernel\n"
"def set_pixels():\n"
"    for i, j, k in pixels:\n"
"        pixels[i, j, k] = ti.random() * 255\n"
"\n"
"set_pixels()\n"
"filename = f'imwrite_export.png'\n"
"ti.imwrite(pixels.to_numpy(), filename)\n"
"print(f'The image has been saved to {filename}')"
msgstr ""

#: ../../export_results.rst:70
msgid ""
"``ti.imwrite`` can export Taichi tensors (``ti.Matrix``, ``ti.Vector``, ``ti."
"var``) and numpy tensors ``np.ndarray``."
msgstr ""
"``ti.imwrite`` 可以导出 Taichi 张量 (``ti.Matrix``, ``ti.Vector``, ``ti."
"var``) 和 numpy 张量 ``np.ndarray``."

#: ../../export_results.rst:71
msgid ""
"Same as above ``ti.GUI.show(filename)``, the image format (``png``, ``jpg`` "
"and ``bmp``) is also controlled by the suffix of ``filename`` in ``ti."
"imwrite(filename)``."
msgstr ""
"与之前讲到的 ``ti.GUI.show(filename)`` 一样, 图像格式 (``png``, ``jpg`` 和 "
"``bmp``) 依旧由 ``ti.imwrite(文件名)`` 中 ``文件名`` 包含的后缀所决定."

#: ../../export_results.rst:72
msgid ""
"Meanwhile, the resulted image type (grayscale, RGB, or RGBA) is determined "
"by **the number of channels in the input tensor**, i.e., the length of the "
"third dimension (``tensor.shape[2]``)."
msgstr ""
"同时，得到的图像类型（灰度、RGB 或 RGBA）由 **输入张量的通道数** 决定。即，第"
"三维的长度( ``tensor.shape[2]`` )。"

#: ../../export_results.rst:73
msgid ""
"In other words, a tensor that has shape ``(w, h)`` or ``(w, h, 1)`` will be "
"exported as a grayscale image."
msgstr "换言之，形状是 ``(w, h)`` 或 ``(w, h, 1)`` 的张量会被导出成灰度图。"

#: ../../export_results.rst:74
msgid ""
"If you want to export ``RGB`` or ``RGBA`` images instead, the input tensor "
"should have a shape ``(w, h, 3)`` or ``(w, h, 4)`` respectively."
msgstr ""
"如果你想导出 ``RGB`` 或 ``RGBA`` 的图像，输入的张量形状应该分别是 ``(w, h, "
"3)`` 或 ``(w, h, 4)``。"

#: ../../export_results.rst:78
msgid ""
"All Taichi tensors have their own data types, such as ``ti.u8`` and ``ti."
"f32``. Different data types can lead to different behaviors of ``ti."
"imwrite``. Please check out :ref:`gui` for more details."
msgstr ""
"Taichi 中所有的张量都有自己的数据类型，比如 ``ti.u8`` 和 ``ti.f32``。不同的数"
"据类型会导致 ``ti.imwrite`` 产生不同的输出。请参阅 :ref:`gui` 了解更多细节。"

#: ../../export_results.rst:80
msgid ""
"Taichi offers other helper functions that read and show images in addition "
"to ``ti.imwrite``. They are also demonstrated in :ref:`gui`."
msgstr ""
"除了 ``ti.imwrite`` 之外，Taichi 还提供了其他读取和显示图像的辅助函数。在 :"
"ref:`gui` 中也会有它们的示例。"

#: ../../export_results.rst:83
msgid "Export videos"
msgstr "导出视频"

#: ../../export_results.rst:87
msgid ""
"The video export utilities of Taichi depend on ``ffmpeg``. If ``ffmpeg`` is "
"not installed on your machine, please follow the installation instructions "
"of ``ffmpeg`` at the end of this page."
msgstr ""
"Taichi 的视频导出工具依赖于 ``ffmpeg``。如果你的机器上还没有安装 ``ffmpeg``，"
"请按照本节末尾的 ``ffmpeg`` 安装说明进行操作。"

#: ../../export_results.rst:89
msgid ""
"``ti.VideoManger`` can help you export results in ``mp4`` or ``gif`` format. "
"For example,"
msgstr "``ti.VideoManger`` 可以帮助你导出 mp4 或 gif 格式的结果。例如,"

#: ../../export_results.rst:91
msgid ""
"import taichi as ti\n"
"\n"
"ti.init()\n"
"\n"
"pixels = ti.var(ti.u8, shape=(512, 512, 3))\n"
"\n"
"@ti.kernel\n"
"def paint():\n"
"    for i, j, k in pixels:\n"
"        pixels[i, j, k] = ti.random() * 255\n"
"\n"
"result_dir = \"./results\"\n"
"video_manger = ti.VideoManager(output_dir=result_dir, framerate=24, "
"automatic_build=False)\n"
"\n"
"for i in range(50):\n"
"    paint()\n"
"\n"
"    pixels_img = pixels.to_numpy()\n"
"    video_manger.write_frame(pixels_img)\n"
"    print(f'\\rFrame {i+1}/50 is recorded', end='')\n"
"\n"
"print()\n"
"print('Exporting .mp4 and .gif videos...')\n"
"video_manger.make_video(gif=True, mp4=True)\n"
"print(f'MP4 video is saved to {video_manger.get_output_filename(\"."
"mp4\")}')\n"
"print(f'GIF video is saved to {video_manger.get_output_filename(\".gif\")}')"
msgstr ""

#: ../../export_results.rst:120
msgid ""
"After running the code above, you will find the output videos in the ``./"
"results/`` folder."
msgstr "运行上述代码后，你将在 ``./results/`` 文件夹中找到输出的视频。"

#: ../../export_results.rst:123
msgid "Install ffmpeg"
msgstr "安装 ffmpeg"

#: ../../export_results.rst:126
msgid "Install ffmpeg on Windows"
msgstr "在 Windows 上安装 ffmpeg"

#: ../../export_results.rst:128
msgid ""
"Download the ``ffmpeg`` archive(named ``ffmpeg-2020xxx.zip``) from `ffmpeg "
"<https://ffmpeg.org/download.html>`_;"
msgstr ""
"从 `ffmpeg <https://ffmpeg.org/download.html>`_ 上下载 ``ffmpeg`` 存档文件"
"（具体名称为，``ffmpeg-2020xxx.zip``）;"

#: ../../export_results.rst:130
msgid "Unzip this archive to a folder, such as \"D:/YOUR_FFMPEG_FOLDER\";"
msgstr "解压存档到指定文件夹中，比如， “D:/YOUR_FFMPEG_FOLDER”;"

#: ../../export_results.rst:132
msgid ""
"**Important:** add ``D:/YOUR_FFMPEG_FOLDER/bin`` to the ``PATH`` environment "
"variable;"
msgstr ""
"**关键步骤：** 添加路径 ``D:/YOUR_FFMPEG_FOLDER/bin`` 到环境变量 ``PATH`` 中;"

#: ../../export_results.rst:134
msgid ""
"Open the Windows ``cmd`` or ``PowerShell`` and type the line of code below "
"to test your installation. If ``ffmpeg`` is set up properly, the version "
"information will be printed."
msgstr ""
"打开 Windows 下的 ``cmd`` 或 ``PowerShell`` ，然后输入下面这行命令来测试你的"
"安装是否成功。 如果 ``ffmpeg`` 已经正确安装完毕，那么它的版本信息就会被打印出"
"来。"

#: ../../export_results.rst:136
msgid "ffmpeg -version"
msgstr ""

#: ../../export_results.rst:141
msgid "Install ``ffmpeg`` on Linux"
msgstr "在 Linux 上安装 ``ffmpeg``"

#: ../../export_results.rst:142
msgid ""
"Most Linux distribution came with ``ffmpeg`` natively, so you do not need to "
"read this part if the ``ffmpeg`` command is already there on your machine."
msgstr ""
"大多数 Linux 发行版都会自带 ``ffmpeg`` ，所以如果你的机器上已经有了 "
"``ffmpeg`` 命令，那么你就不需要阅读这一部分了。"

#: ../../export_results.rst:143
msgid "Install ``ffmpeg`` on Ubuntu"
msgstr "在 Ubuntu 上安装 ``ffmpeg``"

#: ../../export_results.rst:145
msgid ""
"sudo apt-get update\n"
"sudo apt-get install ffmpeg"
msgstr ""

#: ../../export_results.rst:150
msgid "Install ``ffmpeg`` on CentOS and RHEL"
msgstr "在  CentOS 和 RHEL 上安装 ``ffmpeg``"

#: ../../export_results.rst:152
msgid "sudo yum install ffmpeg ffmpeg-devel"
msgstr ""

#: ../../export_results.rst:156
msgid "Install ``ffmpeg`` on Arch Linux:"
msgstr "在 Arch Linux 上安装 ``ffmpeg``:"

#: ../../export_results.rst:162
msgid "Test your installation using"
msgstr "使用下面这行命令测试你的安装是否成功"

#: ../../export_results.rst:164
msgid "ffmpeg -h"
msgstr ""

#: ../../export_results.rst:169
msgid "Install ``ffmpeg`` on OS X"
msgstr "在 OS X 上安装 ``ffmpeg``"

#: ../../export_results.rst:171
msgid "``ffmpeg`` can be installed on OS X using ``homebrew``:"
msgstr "在  OS X  上可以通过 ``homebrew`` 安装 ``ffmpeg``:"

#: ../../export_results.rst:173
msgid "brew install ffmpeg"
msgstr ""

#: ../../export_results.rst:178
msgid "Export PLY files"
msgstr "导出 PLY 文件"

#: ../../export_results.rst:179
msgid ""
"``ti.PLYwriter`` can help you export results in the ``ply`` format. Below is "
"a short example of exporting 10 frames of a moving cube with vertices "
"randomly colored,"
msgstr ""
"``ti.PLYwriter`` 可以帮助你将结果导出为 ``ply`` 格式。下面是导出一个顶点随机"
"着色的立方体动画中10帧画面的短例,"

#: ../../export_results.rst:181
msgid ""
"import taichi as ti\n"
"import numpy as np\n"
"\n"
"ti.init(arch=ti.cpu)\n"
"\n"
"num_vertices = 1000\n"
"pos = ti.Vector(3, dt=ti.f32, shape=(10, 10, 10))\n"
"rgba = ti.Vector(4, dt=ti.f32, shape=(10, 10, 10))\n"
"\n"
"\n"
"@ti.kernel\n"
"def place_pos():\n"
"    for i, j, k in pos:\n"
"        pos[i, j, k] = 0.1 * ti.Vector([i, j, k])\n"
"\n"
"\n"
"@ti.kernel\n"
"def move_particles():\n"
"    for i, j, k in pos:\n"
"        pos[i, j, k] += ti.Vector([0.1, 0.1, 0.1])\n"
"\n"
"\n"
"@ti.kernel\n"
"def fill_rgba():\n"
"    for i, j, k in rgba:\n"
"        rgba[i, j, k] = ti.Vector(\n"
"            [ti.random(), ti.random(), ti.random(), ti.random()])\n"
"\n"
"\n"
"place_pos()\n"
"series_prefix = \"example.ply\"\n"
"for frame in range(10):\n"
"    move_particles()\n"
"    fill_rgba()\n"
"    # now adding each channel only supports passing individual np.array\n"
"    # so converting into np.ndarray, reshape\n"
"    # remember to use a temp var to store so you dont have to convert back\n"
"    np_pos = np.reshape(pos.to_numpy(), (num_vertices, 3))\n"
"    np_rgba = np.reshape(rgba.to_numpy(), (num_vertices, 4))\n"
"    # create a PLYWriter\n"
"    writer = ti.PLYWriter(num_vertices=num_vertices)\n"
"    writer.add_vertex_pos(np_pos[:, 0], np_pos[:, 1], np_pos[:, 2])\n"
"    writer.add_vertex_rgba(\n"
"        np_rgba[:, 0], np_rgba[:, 1], np_rgba[:, 2], np_rgba[:, 3])\n"
"    writer.export_frame_ascii(frame, series_prefix)"
msgstr ""
"import taichi as ti\n"
"import numpy as np\n"
"\n"
"ti.init(arch=ti.cpu)\n"
"\n"
"num_vertices = 1000\n"
"pos = ti.Vector(3, dt=ti.f32, shape=(10, 10, 10))\n"
"rgba = ti.Vector(4, dt=ti.f32, shape=(10, 10, 10))\n"
"\n"
"\n"
"@ti.kernel\n"
"def place_pos():\n"
"    for i, j, k in pos:\n"
"        pos[i, j, k] = 0.1 * ti.Vector([i, j, k])\n"
"\n"
"\n"
"@ti.kernel\n"
"def move_particles():\n"
"    for i, j, k in pos:\n"
"        pos[i, j, k] += ti.Vector([0.1, 0.1, 0.1])\n"
"\n"
"\n"
"@ti.kernel\n"
"def fill_rgba():\n"
"    for i, j, k in rgba:\n"
"        rgba[i, j, k] = ti.Vector(\n"
"            [ti.random(), ti.random(), ti.random(), ti.random()])\n"
"\n"
"\n"
"place_pos()\n"
"series_prefix = \"example.ply\"\n"
"for frame in range(10):\n"
"    move_particles()\n"
"    fill_rgba()\n"
"    # 当前只支持通过传递单个 np.array 来添加通道\n"
"    # 所以需要转换为 np.ndarray 并且 reshape\n"
"    # 记住使用一个临时变量来存储，这样你就不必再转换回来\n"
"    np_pos = np.reshape(pos.to_numpy(), (num_vertices, 3))\n"
"    np_rgba = np.reshape(rgba.to_numpy(), (num_vertices, 4))\n"
"    # 创建一个 PLYWriter 对象\n"
"    writer = ti.PLYWriter(num_vertices=num_vertices)\n"
"    writer.add_vertex_pos(np_pos[:, 0], np_pos[:, 1], np_pos[:, 2])\n"
"    writer.add_vertex_rgba(\n"
"        np_rgba[:, 0], np_rgba[:, 1], np_rgba[:, 2], np_rgba[:, 3])\n"
"    writer.export_frame_ascii(frame, series_prefix)"

#: ../../export_results.rst:229
msgid ""
"After running the code above, you will find the output sequence of ``ply`` "
"files in the current working directory. Next, we will break down the usage "
"of ``ti.PLYWriter`` into 4 steps and show some examples."
msgstr ""
"运行上述代码后，你将在当前工作目录中找到 ``ply`` 文件的输出序列。接下来，我们"
"将 ``ti.PLYWriter`` 的使用方式分解为4个步骤，并相应的展示一些示例。"

#: ../../export_results.rst:231
msgid "Setup ``ti.PLYWriter``"
msgstr "设置 ``ti.PLYWriter``"

#: ../../export_results.rst:233
msgid ""
"# num_vertices must be a positive int\n"
"# num_faces is optional, default to 0\n"
"# face_type can be either \"tri\" or \"quad\", default to \"tri\"\n"
"\n"
"# in our previous example, a writer with 1000 vertices and 0 triangle faces "
"is created\n"
"num_vertices = 1000\n"
"writer = ti.PLYWriter(num_vertices=num_vertices)\n"
"\n"
"# in the below example, a writer with 20 vertices and 5 quadrangle faces is "
"created\n"
"writer2 = ti.PLYWriter(num_vertices=20, num_faces=5, face_type=\"quad\")"
msgstr ""
"# num_vertices 必须是正整数\n"
"# num_faces 是可选的，默认为0\n"
"# face_type 可以是 \"tri\" 或 \"quad\", 默认为 \"tri\"\n"
"\n"
"# 在之前的例子中，创建了一个带有1000个顶点和0个三角形面片的写入器(writer)\n"
"num_vertices = 1000\n"
"writer = ti.PLYWriter(num_vertices=num_vertices)\n"
"\n"
"# 在下面的例子中，创建了一个带有20个顶点和5个四边形面片的写入器\n"
"writer2 = ti.PLYWriter(num_vertices=20, num_faces=5, face_type=\"quad\")"

#: ../../export_results.rst:246
msgid "Add required channels"
msgstr "添加必需的通道信息"

#: ../../export_results.rst:248
msgid ""
"# A 2D grid with quad faces\n"
"#     y\n"
"#     |\n"
"# z---/\n"
"#    x\n"
"#         19---15---11---07---03\n"
"#         |    |    |    |    |\n"
"#         18---14---10---06---02\n"
"#         |    |    |    |    |\n"
"#         17---13---19---05---01\n"
"#         |    |    |    |    |\n"
"#         16---12---08---04---00\n"
"\n"
"writer = ti.PLYWriter(num_vertices=20, num_faces=12, face_type=\"quad\")\n"
"\n"
"# For the vertices, the only required channel is the position,\n"
"# which can be added by passing 3 np.array x, y, z into the following "
"function.\n"
"\n"
"x = np.zeros(20)\n"
"y = np.array(list(np.arange(0, 4))*5)\n"
"z = np.repeat(np.arange(5), 4)\n"
"writer.add_vertex_pos(x, y, z)\n"
"\n"
"# For faces (if any), the only required channel is the list of vertex "
"indices that each face contains.\n"
"indices = np.array([0, 1, 5, 4]*12)+np.repeat(\n"
"    np.array(list(np.arange(0, 3))*4)+4*np.repeat(np.arange(4), 3), 4)\n"
"writer.add_faces(indices)"
msgstr ""
"# 一个由四边形面片组成的二维网格\n"
"#     y\n"
"#     |\n"
"# z---/\n"
"#    x\n"
"#         19---15---11---07---03\n"
"#         |    |    |    |    |\n"
"#         18---14---10---06---02\n"
"#         |    |    |    |    |\n"
"#         17---13---19---05---01\n"
"#         |    |    |    |    |\n"
"#         16---12---08---04---00\n"
"\n"
"writer = ti.PLYWriter(num_vertices=20, num_faces=12, face_type=\"quad\")\n"
"\n"
"# 对于顶点来说，唯一必需的通道信息就是位置,\n"
"# 可以通过向下列函数中传递三个 np.array x,y,z 来添加\n"
"\n"
"x = np.zeros(20)\n"
"y = np.array(list(np.arange(0, 4))*5)\n"
"z = np.repeat(np.arange(5), 4)\n"
"writer.add_vertex_pos(x, y, z)\n"
"\n"
"# 对于面片来说（如果有的话），唯一必需的通道信息是每个面片所包含的顶点索引列"
"表。\n"
"indices = np.array([0, 1, 5, 4]*12)+np.repeat(\n"
"    np.array(list(np.arange(0, 3))*4)+4*np.repeat(np.arange(4), 3), 4)\n"
"writer.add_faces(indices)"

#: ../../export_results.rst:278
msgid "Add optional channels"
msgstr "添加可选的通道信息"

#: ../../export_results.rst:280
msgid ""
"# Add custome vertex channel, the input should include a key, a supported "
"datatype and, the data np.array\n"
"vdata = np.random.rand(20)\n"
"writer.add_vertex_channel(\"vdata1\", \"double\", vdata)\n"
"\n"
"# Add custome face channel\n"
"foo_data = np.zeros(12)\n"
"writer.add_face_channel(\"foo_key\", \"foo_data_type\", foo_data)\n"
"# error! because \"foo_data_type\" is not a supported datatype. Supported "
"ones are\n"
"# ['char', 'uchar', 'short', 'ushort', 'int', 'uint', 'float', 'double']\n"
"\n"
"# PLYwriter already defines several useful helper functions for common "
"channels\n"
"# Add vertex color, alpha, and rgba\n"
"# using float/double r g b alpha to reprent color, the range should be 0 to "
"1\n"
"r = np.random.rand(20)\n"
"g = np.random.rand(20)\n"
"b = np.random.rand(20)\n"
"alpha = np.random.rand(20)\n"
"writer.add_vertex_color(r, g, b)\n"
"writer.add_vertex_alpha(alpha)\n"
"# equivilantly\n"
"# add_vertex_rgba(r, g, b, alpha)\n"
"\n"
"# vertex normal\n"
"writer.add_vertex_normal(np.ones(20), np.zeros(20), np.zeros(20))\n"
"\n"
"# vertex index, and piece (group id)\n"
"writer.add_vertex_id()\n"
"writer.add_vertex_piece(np.ones(20))\n"
"\n"
"# Add face index, and piece (group id)\n"
"# Indexing the existing faces in the writer and add this channel to face "
"channels\n"
"writer.add_face_id()\n"
"# Set all the faces is in group 1\n"
"writer.add_face_piece(np.ones(12))"
msgstr ""
"# 添加自定义顶点通道信息，输入应该包括一个键(key)，支持的数据类型，np.array格"
"式的数据\n"
"vdata = np.random.rand(20)\n"
"writer.add_vertex_channel(\"vdata1\", \"double\", vdata)\n"
"\n"
"# 添加自定义面片通道信息\n"
"foo_data = np.zeros(12)\n"
"writer.add_face_channel(\"foo_key\", \"foo_data_type\", foo_data)\n"
"# 错误! 因为 \"foo_data_type\" 并不是支持的数据类型. 支持的数据类型有如下\n"
"# ['char', 'uchar', 'short', 'ushort', 'int', 'uint', 'float', 'double']\n"
"\n"
"# PLYwriter 已经为常用通道定义了几个有用的辅助函数\n"
"# 添加顶点的颜色, alpha通道, 及 rgba\n"
"# 使用 float/double r g b alpha 来表示颜色值, 范围应该在0到1之间\n"
"r = np.random.rand(20)\n"
"g = np.random.rand(20)\n"
"b = np.random.rand(20)\n"
"alpha = np.random.rand(20)\n"
"writer.add_vertex_color(r, g, b)\n"
"writer.add_vertex_alpha(alpha)\n"
"# 相当于\n"
"# add_vertex_rgba(r, g, b, alpha)\n"
"\n"
"# 顶点法向\n"
"writer.add_vertex_normal(np.ones(20), np.zeros(20), np.zeros(20))\n"
"\n"
"# 顶点索引和块(组内 id)\n"
"writer.add_vertex_id()\n"
"writer.add_vertex_piece(np.ones(20))\n"
"\n"
"# 添加面片索引和块 (组内 id)\n"
"# 在 writer 中索引已有面片并将其通道信息添加到面片通道信息中\n"
"writer.add_face_id()\n"
"# 将所有的面片都放到第一组\n"
"writer.add_face_piece(np.ones(12))"

#: ../../export_results.rst:317
msgid "Export files"
msgstr "导出文件"

#: ../../export_results.rst:319
msgid ""
"series_prefix = \"example.ply\"\n"
"series_prefix_ascii = \"example_ascii.ply\"\n"
"# Export a single file\n"
"# use ascii so you can read the content\n"
"writer.export_ascii(series_prefix_ascii)\n"
"\n"
"# alternatively, use binary for a bit better performance\n"
"# writer.export(series_prefix)\n"
"\n"
"# Export a sequence of files, ie in 10 frames\n"
"for frame in range(10):\n"
"    # write each frame as i.e. \"example_000000.ply\" in your current "
"running folder\n"
"    writer.export_frame_ascii(frame, series_prefix_ascii)\n"
"    # alternatively, use binary\n"
"    # writer.export_frame(frame, series_prefix)\n"
"\n"
"    # update location/color\n"
"    x = x + 0.1*np.random.rand(20)\n"
"    y = y + 0.1*np.random.rand(20)\n"
"    z = z + 0.1*np.random.rand(20)\n"
"    r = np.random.rand(20)\n"
"    g = np.random.rand(20)\n"
"    b = np.random.rand(20)\n"
"    alpha = np.random.rand(20)\n"
"    # re-fill\n"
"    writer = ti.PLYWriter(num_vertices=20, num_faces=12, face_type=\"quad"
"\")\n"
"    writer.add_vertex_pos(x, y, z)\n"
"    writer.add_faces(indices)\n"
"    writer.add_vertex_channel(\"vdata1\", \"double\", vdata)\n"
"    writer.add_vertex_color(r, g, b)\n"
"    writer.add_vertex_alpha(alpha)\n"
"    writer.add_vertex_normal(np.ones(20), np.zeros(20), np.zeros(20))\n"
"    writer.add_vertex_id()\n"
"    writer.add_vertex_piece(np.ones(20))\n"
"    writer.add_face_id()\n"
"    writer.add_face_piece(np.ones(12))"
msgstr ""
"series_prefix = \"example.ply\"\n"
"series_prefix_ascii = \"example_ascii.ply\"\n"
"# 导出一个简单的文件\n"
"# 使用 ascii 编码这样你可以对内容进行概览\n"
"writer.export_ascii(series_prefix_ascii)\n"
"\n"
"# 或者，使用二进制编码以获得更好的性能\n"
"# writer.export(series_prefix)\n"
"\n"
"# 导出文件序列，即10帧\n"
"for frame in range(10):\n"
"    # 将每一帧写入你的当前运行的文件夹中( 即， \"example_000000.ply\")\n"
"    writer.export_frame_ascii(frame, series_prefix_ascii)\n"
"    # 或者相应的, 使用二进制编码这样写\n"
"    # writer.export_frame(frame, series_prefix)\n"
"\n"
"    # 更新 位置/颜色\n"
"    x = x + 0.1*np.random.rand(20)\n"
"    y = y + 0.1*np.random.rand(20)\n"
"    z = z + 0.1*np.random.rand(20)\n"
"    r = np.random.rand(20)\n"
"    g = np.random.rand(20)\n"
"    b = np.random.rand(20)\n"
"    alpha = np.random.rand(20)\n"
"    # 重新填充\n"
"    writer = ti.PLYWriter(num_vertices=20, num_faces=12, face_type=\"quad"
"\")\n"
"    writer.add_vertex_pos(x, y, z)\n"
"    writer.add_faces(indices)\n"
"    writer.add_vertex_channel(\"vdata1\", \"double\", vdata)\n"
"    writer.add_vertex_color(r, g, b)\n"
"    writer.add_vertex_alpha(alpha)\n"
"    writer.add_vertex_normal(np.ones(20), np.zeros(20), np.zeros(20))\n"
"    writer.add_vertex_id()\n"
"    writer.add_vertex_piece(np.ones(20))\n"
"    writer.add_face_id()\n"
"    writer.add_face_piece(np.ones(12))"

#: ../../export_results.rst:359
msgid "Import ``ply`` files into Houdini and Blender"
msgstr "将 ``ply`` 文件导出到 Houdini 和 Blender"

#: ../../export_results.rst:360
msgid ""
"Houdini supports importing a series of ``ply`` files sharing the same prefix/"
"post-fix. Our ``export_frame`` can achieve the requirement for you. In "
"Houdini, click ``File->Import->Geometry`` and navigate to the folder "
"containing your frame results, who should be collapsed into one single entry "
"like ``example_$F6.ply (0-9)``. Double-click this entry to finish the "
"importing process."
msgstr ""
"Houdini 支持导入一组共享相同前缀/后缀的 ``ply`` 文件。我们的 "
"``export_frame`` 就可以为你满足这种需求。在 Houdini 中，点击 ``File->Import-"
">Geometry`` 并导航至包含你的框架输出的文件夹中，这些输出结果应该被梳理成一个"
"单一的条目，比如  ``example_$F6.ply (0-9)``。双击该条目以完成导入过程。"

#: ../../export_results.rst:362
msgid ""
"Blender requires an add-on called `Stop-motion-OBJ <https://github.com/"
"neverhood311/Stop-motion-OBJ>`_ to load the result sequences. A very "
"detailed explanation `video <https://www.youtube.com/watch?v=Ja7F7WHD39Q>`_ "
"is provided by the author on how to install, enable, and use the add-on. "
"Just keep in mind that significant changes in the workflow were made in "
"their most recent test releases. To follow their instruction readme and "
"video, please use ``v2.0.2``."
msgstr ""
"Blender 需要一个名为 `Stop-motion-OBJ <https://github.com/neverhood311/Stop-"
"motion-OBJ>`_ 的插件来加载结果序列。这里有一个非常详尽的 `教程视频 <https://"
"www.youtube.com/watch?v=Ja7F7WHD39Q>`_，是由其作者提供的关于如何安装、授权和"
"使用这个插件的演示。需要注意的一点是，Stop-motion-OBJ 工作流的重大变更是在最"
"近的测试版本中才释放来的。如要跟随他们的说明文档和视频学习和使用，请使用 "
"``v2.0.2`` 版本。"
