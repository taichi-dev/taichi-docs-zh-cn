# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2018, Yuanming Hu
# This file is distributed under the same license as the taichi package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2020.
#
msgid ""
msgstr ""
"Project-Id-Version: taichi 0.5.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-05-13 20:53-0400\n"
"PO-Revision-Date: 2020-05-18 23:33+0800\n"
"Last-Translator: archibate <17721388340@qq.com>\n"
"Language: zh_CN\n"
"Language-Team: \n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.8.0\n"
"X-Generator: Poedit 2.3\n"

#: ../../syntax.rst:2
msgid "Syntax"
msgstr "语法"

#: ../../syntax.rst:5
msgid "Kernels"
msgstr "内核"

#: ../../syntax.rst:7
msgid ""
"Kernel arguments must be type-hinted. Kernels can have at most 8 parameters, "
"e.g.,"
msgstr "内核参数必须有类型提示。内核最多只能有 8 个参数，例如,"

#: ../../syntax.rst:9
msgid ""
"@ti.kernel\n"
"def print_xy(x: ti.i32, y: ti.f32):\n"
"    print(x + y)"
msgstr ""

#: ../../syntax.rst:16
msgid ""
"A kernel can have a **scalar** return value. If a kernel has a return value, "
"it must be type-hinted. The return value will be automatically cast into the "
"hinted type. e.g.,"
msgstr ""

#: ../../syntax.rst:19
msgid ""
"@ti.kernel\n"
"def add_xy(x: ti.f32, y: ti.f32) -> ti.i32:\n"
"    return x + y  # same as: ti.cast(x + y, ti.i32)\n"
"\n"
"res = add_xy(2.3, 1.1)\n"
"print(res)  # 3, since return type is ti.i32"
msgstr ""

#: ../../syntax.rst:31
msgid ""
"For now, we only support one scalar as return value. Returning ``ti.Matrix`` "
"or ``ti.Vector`` is not supported. Python-style tuple return is not "
"supported either. For example:"
msgstr ""

#: ../../syntax.rst:33
msgid ""
"@ti.kernel\n"
"def bad_kernel() -> ti.Matrix:\n"
"    return ti.Matrix([[1, 0], [0, 1]])  # Error\n"
"\n"
"@ti.kernel\n"
"def bad_kernel() -> (ti.i32, ti.f32):\n"
"    x = 1\n"
"    y = 0.5\n"
"    return x, y  # Error"
msgstr ""

#: ../../syntax.rst:46
msgid ""
"We also support **template arguments** (see :ref:`template_metaprogramming`) "
"and **external array arguments** (see :ref:`external`) in Taichi kernels."
msgstr ""

#: ../../syntax.rst:50
msgid ""
"When using differentiable programming, there are a few more constraints on "
"kernel structures. See the **Kernel Simplicity Rule** in :ref:"
"`differentiable`."
msgstr ""

#: ../../syntax.rst:52
msgid ""
"Also, please do not use kernel return values in differentiable programming, "
"since the return value will not be tracked by automatic differentiation. "
"Instead, store the result into a global variable (e.g. ``loss[None]``)."
msgstr ""

#: ../../syntax.rst:55
msgid "Functions"
msgstr "函数"

#: ../../syntax.rst:57
msgid ""
"Use ``@ti.func`` to decorate your Taichi functions. These functions are "
"callable only in `Taichi`-scope. Do not call them in `Python`-scopes."
msgstr ""
"使用 ``@ti.func`` 来装饰您的 Taichi 函数。这些函数只能在 `Taichi` 作用域内调"
"用。不要在 `Python` 作用域内调用它们。"

#: ../../syntax.rst:59
msgid ""
"@ti.func\n"
"def laplacian(t, i, j):\n"
"    return inv_dx2 * (\n"
"        -4 * p[t, i, j] + p[t, i, j - 1] + p[t, i, j + 1] + p[t, i + 1, j] "
"+\n"
"        p[t, i - 1, j])\n"
"\n"
"@ti.kernel\n"
"def fdtd(t: ti.i32):\n"
"    for i in range(n_grid): # Parallelized\n"
"        for j in range(n_grid): # Serial loops in each parallel threads\n"
"            laplacian_p = laplacian(t - 2, i, j)\n"
"            laplacian_q = laplacian(t - 1, i, j)\n"
"            p[t, i, j] = 2 * p[t - 1, i, j] + (\n"
"                c * c * dt * dt + c * alpha * dt) * laplacian_q - p[\n"
"                           t - 2, i, j] - c * alpha * dt * laplacian_p"
msgstr ""
"@ti.func\n"
"def laplacian(t, i, j):\n"
"  return inv_dx2 * (\n"
"      -4 * p[t, i, j] + p[t, i, j - 1] + p[t, i, j + 1] + p[t, i + 1, j] +\n"
"      p[t, i - 1, j])\n"
"\n"
"@ti.kernel\n"
"def fdtd(t: ti.i32):\n"
"  for i in range(n_grid): # 并行\n"
"    for j in range(n_grid): # 在每个并行的线程中分别顺序执行\n"
"      laplacian_p = laplacian(t - 2, i, j)\n"
"      laplacian_q = laplacian(t - 1, i, j)\n"
"      p[t, i, j] = 2 * p[t - 1, i, j] + (\n"
"          c * c * dt * dt + c * alpha * dt) * laplacian_q - p[\n"
"                     t - 2, i, j] - c * alpha * dt * laplacian_p"

#: ../../syntax.rst:80
msgid ""
"Functions with multiple ``return`` statements are not supported for now. Use "
"a **local** variable to store the results, so that you end up with only one "
"``return`` statement:"
msgstr ""
"目前不支持具有多个 ``return`` 语句的函数。请用 **局部变量** 暂存结果，以便最"
"终只有一个 ``return`` ："

#: ../../syntax.rst:82
msgid ""
"# Bad function - two return statements\n"
"@ti.func\n"
"def safe_sqrt(x):\n"
"  if x >= 0:\n"
"    return ti.sqrt(x)\n"
"  else:\n"
"    return 0.0\n"
"\n"
"# Good function - single return statement\n"
"@ti.func\n"
"def safe_sqrt(x):\n"
"  rst = 0.0\n"
"  if x >= 0:\n"
"    rst = ti.sqrt(x)\n"
"  else:\n"
"    rst = 0.0\n"
"  return rst"
msgstr ""
"# 错误示范 - 两个返回语句\n"
"@ti.func\n"
"def safe_sqrt(x):\n"
"  if x >= 0:\n"
"    return ti.sqrt(x)\n"
"  else:\n"
"    return 0.0\n"
"\n"
"# 正确示范 - 一个返回语句\n"
"@ti.func\n"
"def safe_sqrt(x):\n"
"  rst = 0.0\n"
"  if x >= 0:\n"
"    rst = ti.sqrt(x)\n"
"  else:\n"
"    rst = 0.0\n"
"  return rst"

#: ../../syntax.rst:104
msgid ""
"Currently, all functions are force-inlined. Therefore, no recursion is "
"allowed."
msgstr ""
"目前，所有函数都是强制内联的。因此，不能使用递归。<div align=\"center\">\n"
"  <img width=\"500px\" src=\"https://github.com/yuanming-hu/taichi/raw/"
"master/misc/logo.png\">\n"
"  <h3> <a href=\"https://github.com/taichi-dev/taichi\"> 项目仓库 </a> | <a "
"href=\"https://taichi.readthedocs.io/zh_CN/latest/\"> 中文文档 </a> | <a "
"href=\"https://taichi.readthedocs.io/zh_CN/latest/hello.html\"> 教程 </a> | "
"<a href=\"https://github.com/yuanming-hu/taichi/tree/master/examples\"> 示例 "
"</a> | <a href=\"https://taichi.readthedocs.io/en/latest/contributor_guide."
"html\"> 参与开发 </a> | <a href=\"https://forum.taichi.graphics/\"> 论坛 </"
"a> </h3>\n"
"</div>\n"
"\n"
"----------\n"
"\n"
"# Taichi 官方中文文档\n"
"\n"
"预览地址: https://taichi.readthedocs.io/zh_CN/latest/\n"
"\n"
"| Version | Document Status                                              |\n"
"| ------- | ------------------------------------------------------------ |\n"
"| latest  | [![Documentation Status](https://readthedocs.org/projects/taichi-"
"zh/badge/?version=latest)](https://taichi.readthedocs.io/zh_CN/latest/?"
"badge=latest) |\n"
"\n"
"[Taichi](https://github.com/taichi-dev/taichi) 是一门高效的、以 Python 语法封"
"装的计算机图形应用语言。这里是 Taichi 的中文文档。\n"
"\n"
"----------\n"
"\n"
"# 我如何参与翻译？\n"
"\n"
"## 如果你是第一次\n"
"\n"
"1. 准备下列工具:\n"
"\n"
"  - Git\n"
"  \n"
"  - GitHub 账号\n"
"  \n"
"  - Python 3\n"
"  \n"
"  - 一个 PO 编辑器，推荐 [poedit](https://poedit.net/)\n"
"  \n"
"  - (如果你是 MacOS) 请安装 gettext:\n"
"  \n"
"    ```bash\n"
"    brew install gettext\n"
"    brew link gettext --force\n"
"    ```\n"
"\n"
"1. Fork 本仓库（点击右上角的 Fork 按钮）。\n"
"\n"
"1. 在控制台（powershell 可能会有一些问题，如果你是 windows 可以使用 cmd）执行"
"下列命令:\n"
"\n"
"   ```bash\n"
"   git clone https://github.com/你的用户名/taichi-docs-zh-cn.git --depth=1\n"
"   cd taichi-docs-zh-cn\n"
"   git remote add upstream https://github.com/taichi-dev/taichi-docs-zh-cn."
"git\n"
"   git submodule update --depth=1\n"
"   make all\n"
"   ```\n"
"\n"
"## 翻译前的准备\n"
"\n"
"1. 假如你要翻译的文件是 hello.rst。\n"
"\n"
"1. 在 [Issue 页面](https://github.com/taichi-dev/taichi-docs-zh-cn/issues) 点"
"击 `New Issue`，新建一个 Issue，标题为: `[翻译中] hello`，这是告诉大家你已经"
"在翻译这个文件了，避免重复劳动。当然，也要注意一下是不是已经有人在翻译中"
"了。\n"
"\n"
"1. 在每一次准备开始新的翻译时:\n"
"\n"
"   ```bash\n"
"   git fetch upstream\n"
"   make merge\n"
"   git checkout -b hello upstream/master\n"
"   ```\n"
"   （这里 hello 也可以是任何名字，用**待翻译的文件名**来命名就是不错的选"
"择）\n"
"\n"
"## 开始翻译！\n"
"\n"
"可以看到 `locales/zh_CN/LC_MESSAGES` 文件夹中有很多 .po 文件，这些就是我们要"
"翻译的了。现在用你的 PO 编辑器编辑它们:\n"
"\n"
"   ```bash\n"
"   poedit locales/zh_CN/LC_MESSAGES/hello.po\n"
"   ```\n"
"\n"
"**注意: 翻译时我们只修改 .po 文件，不修改其它的任何文件，比如 .rst。**\n"
"\n"
"**关于翻译的一些规则请看 [Wiki](https://github.com/taichi-dev/taichi-docs-zh-"
"cn/wiki)。**\n"
"\n"
"关于 .po 文件的更多信息，可以查阅 [gettext wiki](https://en.wikipedia.org/"
"wiki/Gettext) 和 [gettext manual](http://www.gnu.org/software/gettext/manual/"
"gettext.html)。\n"
"\n"
"翻译完成后，执行：\n"
"\n"
"   ```bash\n"
"   make html\n"
"   ```\n"
"\n"
"这会新建一个 build 文件夹，里面存放生成的网页文件。\n"
"现在请用浏览器打开 `build/html/index.html`，找到你翻译的那个章节，看一下效"
"果。\n"
"\n"
"## 提交合并请求\n"
"\n"
"如果翻译没问题，就可以push到你的fork仓库了：\n"
"\n"
"```bash\n"
"git add locales\n"
"git commit -m \"[翻译完毕] hello\"\n"
"git push origin HEAD\n"
"```\n"
"\n"
"接着，前往 [Pull requests 页面](https://github.com/taichi-dev/taichi-docs-zh-"
"cn/pulls)。你应该会看到一个黄色的框框，点击其中的 Compare & pull request 按"
"钮。\n"
"填写说明，点击 Create pull request 按钮，这样就发起合并请求了。\n"
"稍后管理员会审核您的翻译，如果没问题，就会合并进本仓库。\n"
"\n"
"Pull request 的详细操作方法可以参考：[Pull Request 的命令行管理](http://www."
"ruanyifeng.com/blog/2017/07/pull_request.html)。\n"
"\n"
"# 如何更新旧翻译？\n"
"\n"
"翻译全被认领了？没关系！你还可以帮我们**更新**旧的翻译。\n"
"\n"
"在 [Issue 页面](https://github.com/taichi-dev/taichi-docs-zh-cn/issues)中，可"
"以看到若干 `[翻译需要更新] hello` 这样的 Issue，这些就是需要更新的翻译了。\n"
"要认领的话，就另外新建一个 Issue，标题为: `[翻译中] hello`。告诉大家你已经在"
"更新这个翻译了。管理员会关闭之前那个 `[翻译需要更新] hello` 的 Issue。\n"
"\n"
"## 开始翻译！\n"
"\n"
"同样是使用 poedit 打开相应的 .po 文件：\n"
"\n"
"```bash\n"
"poedit locales/zh_CN/LC_MESSAGES/hello.po\n"
"```\n"
"\n"
"你会看到其中几行显示为橘黄色字体，那些就是原文档更新需要变动的部分了。\n"
"\n"
"## 我们还有一个小工具...\n"
"\n"
"Taichi 的原文档更新了之后，我们也需要更新相应的中文文档。要想知道哪些部分更新"
"了，可以输入下面的命令：\n"
"\n"
"```bash\n"
"make fuzzy\n"
"```\n"
"\n"
"你会看到几行 .po 文件名，这些就是原文档更新之后存在差异的文件。在有差异的字符"
"串前会有 `#, fuzzy` 的注释。不过该命令暂时只支持 *nix 平台。"

#: ../../syntax.rst:108
msgid "Function arguments are passed by value."
msgstr "函数的参数是以值传递的。"

#: ../../syntax.rst:113
msgid "Scalar arithmetics"
msgstr "标量算术"

#: ../../syntax.rst:114
msgid "Supported scalar functions:"
msgstr "Taichi 支持的标量函数："

#: ../../syntax.rst:140
msgid ""
"Python 3 distinguishes ``/`` (true division) and ``//`` (floor division). "
"For example, ``1.0 / 2.0 = 0.5``, ``1 / 2 = 0.5``, ``1 // 2 = 0``, ``4.2 // "
"2 = 2``. Taichi follows this design:"
msgstr ""
"Python 3 中 ``/`` （浮点数除法）和 ``//`` （整数除法）是区分开来的。例如，"
"``1.0 / 2.0 = 0.5``，``1 / 2 = 0.5``，``1 // 2 = 0``，``4.2 // 2 = 2``。"
"Taichi 也遵循了这个设计："

#: ../../syntax.rst:143
msgid ""
"**true divisions** on integral types will first cast their operands to the "
"default float point type."
msgstr ""
"*浮点数除法 (true divisions)* 用在整数型上会首先将它们的操作数转换到默认的浮"
"点数型。"

#: ../../syntax.rst:144
msgid ""
"**floor divisions** on float-point types will first cast their operands to "
"the default integer type."
msgstr ""
"*整数除法 (floor divisions)* 用在浮点数型上会首先将它们的操作数转换所有函数调"
"用都是强制内联（inline）的，因此不支持递归。到默认的整数型。"

#: ../../syntax.rst:146
msgid ""
"To avoid such implicit casting, you can manually cast your operands to "
"desired types, using ``ti.cast``. See :ref:`default_precisions` for more "
"details on default numerical types."
msgstr ""
"为避免这样的隐式转换，你可以手动使用 ``ti.cast`` 将你的操作数转换为你需要的类"
"型。关于数字类型的更多细节，请查看 :ref:`default_precisions`。"

#: ../../syntax.rst:151
msgid ""
"When these scalar functions are applied on :ref:`matrix` and :ref:`vector`, "
"they are applied in an element-wise manner. For example:"
msgstr ""
"注意：当这些标量函数用于矩阵和向量时，它们会被逐个作用到所有元素，例如："

#: ../../syntax.rst:154
msgid ""
"B = ti.Matrix([[1.0, 2.0, 3.0], [4.0, 5.0, 6.0]])\n"
"\n"
"A = ti.sin(B)\n"
"# is equivalent to\n"
"for i in ti.static(range(2)):\n"
"    for j in ti.static(range(3)):\n"
"        A[i, j] = ti.sin(B[i, j])"
msgstr ""
"B = ti.Matrix([[1.0, 2.0, 3.0], [4.0, 5.0, 6.0]])\n"
"A = ti.sin(B)\n"
"# 等价于:\n"
"for i in ti.static(range(3)):\n"
"    for j in ti.static(range(2)):\n"
"        A[i, j] = ti.sin(B[i, j])"

#: ../../syntax.rst:166
msgid "Debugging"
msgstr "调试"

#: ../../syntax.rst:168
msgid ""
"Debug your program with ``print(x)``. For example, if ``x`` is ``23``, then "
"it prints"
msgstr ""

#: ../../syntax.rst:170
msgid "[debug] x = 23"
msgstr ""

#: ../../syntax.rst:174
msgid "in the console."
msgstr ""

#: ../../syntax.rst:178
msgid ""
"This is not the same as the ``print`` in Python-scope. For now ``print`` in "
"Taichi only takes **scalar numbers** as input. Strings, vectors and matrices "
"are not supported. Please use ``print(v[0]); print(v[1])`` if you want to "
"print a vector."
msgstr ""

#~ msgid ""
#~ "Inplace adds are atomic on global data. I.e., ``a += b`` is equivalent to "
#~ "``ti.atomic_add(a, b)``"
#~ msgstr ""
#~ "全局变量的 *原地加法* （inplace add）是原子性的。即 ``a += b`` 和 ``ti."
#~ "atomic_add(a, b)`` 等价"

#~ msgid "Debug your program with ``print(x)``."
#~ msgstr "使用 ``print(x)`` 调试你的程序。"

#~ msgid ""
#~ "@ti.kernel\n"
#~ "def print_xy(x: ti.i32, y: ti.f32):\n"
#~ "  print(x + y)\n"
#~ "\n"
#~ "@ti.kernel\n"
#~ "def copy(x: ti.template(), y: ti.template()):\n"
#~ "  for i in x:\n"
#~ "    y[i] = x[i]"
#~ msgstr ""
#~ "@ti.kernel\n"
#~ "def print_xy(x: ti.i32, y: ti.f32):\n"
#~ "  print(x + y)\n"
#~ "\n"
#~ "@ti.kernel\n"
#~ "def copy(x: ti.template(), y: ti.template()):\n"
#~ "  for i in x:\n"
#~ "    y[i] = x[i]"

#~ msgid ""
#~ "For differentiable programming kernels should better have either serial "
#~ "statements or a single parallel for-loop. If you don't use differentiable "
#~ "programming, feel free to ignore this tip."
#~ msgstr ""
#~ "对于可微编程，内核中最好使用串行语句或单个并行 for 循环。如果您不使用可微"
#~ "编程，可以忽略此提示。"

#~ msgid ""
#~ "@ti.kernel\n"
#~ "def a_hard_kernel_to_auto_differentiate():\n"
#~ "  sum = 0\n"
#~ "  for i in x:\n"
#~ "    sum += x[i]\n"
#~ "  for i in y:\n"
#~ "    y[i] = sum\n"
#~ "\n"
#~ "# instead, split it into multiple kernels to be nice to the Taichi "
#~ "autodiff compiler:\n"
#~ "\n"
#~ "@ti.kernel\n"
#~ "def reduce():\n"
#~ "  for i in x:\n"
#~ "    sum[None] += x[i]\n"
#~ "\n"
#~ "@ti.kernel\n"
#~ "def assign()\n"
#~ "  for i in y:\n"
#~ "    y[i] = sum[None]\n"
#~ "\n"
#~ "def main():\n"
#~ "  with ti.Tape(loss):\n"
#~ "    ...\n"
#~ "    sum[None] = 0\n"
#~ "    reduce()\n"
#~ "    assign()\n"
#~ "    ..."
#~ msgstr ""
#~ "@ti.kernel\n"
#~ "def a_hard_kernel_to_auto_differentiate():\n"
#~ "  sum = 0\n"
#~ "  for i in x:\n"
#~ "    sum += x[i]\n"
#~ "  for i in y:\n"
#~ "    y[i] = sum\n"
#~ "\n"
#~ "# 相对地，将上面的部分拆为多个内核对 Taichi 的自动差异 (autodiff) 编译器更"
#~ "好\n"
#~ "\n"
#~ "@ti.kernel\n"
#~ "def reduce():\n"
#~ "  for i in x:\n"
#~ "    sum[None] += x[i]\n"
#~ "\n"
#~ "@ti.kernel\n"
#~ "def assign()\n"
#~ "  for i in y:\n"
#~ "    y[i] = sum[None]\n"
#~ "\n"
#~ "def main():\n"
#~ "  with ti.Tape(loss):\n"
#~ "    ...\n"
#~ "    sum[None] = 0\n"
#~ "    reduce()\n"
#~ "    assign()\n"
#~ "    ..."

#~ msgid "Data layout"
#~ msgstr "数据结构"

#~ msgid ""
#~ "Non-power-of-two tensor dimensions are promoted into powers of two and "
#~ "thus these tensors will occupy more virtual address space. For example, a "
#~ "tensor of size ``(18, 65)`` will be materialized as ``(32, 128)``."
#~ msgstr ""
#~ "非二次幂（power-of-two）的张量维度将被提升至二次幂，因此这些张量将占据更多"
#~ "的虚拟地址空间。例如，一个 ``(18, 65)`` 大小的张量将会被实例化为 ``(32, "
#~ "128)`` 的大小。"

#~ msgid "Why Python frontend"
#~ msgstr "为什么选用 Python 作为前端"

#~ msgid "Embedding the language in ``python`` has the following advantages:"
#~ msgstr "将语言嵌入到 ``python`` 有如下优点："

#~ msgid "Easy to learn. Taichi has a very similar syntax to Python."
#~ msgstr "容易学习。Taichi 具有和 Python 非常相似的语法。"

#~ msgid "Easy to run. No ahead-of-time compilation is needed."
#~ msgstr "容易运行。无需预先编译即可运行。"

#~ msgid "This design allows people to reuse existing python infrastructure:"
#~ msgstr "这种设计使我们得以重用 python 的基础设施："

#~ msgid ""
#~ "IDEs. A python IDE mostly works for Taichi with syntax highlighting, "
#~ "syntax checking, and autocomplete."
#~ msgstr ""
#~ "集成开发环境（IDE）。任何一个 python 的 IDE 将同样支持所有的 Taichi 语法高"
#~ "亮、语法检查和自动补全。"

#~ msgid ""
#~ "Package manager (pip). A developed Taichi application and be easily "
#~ "submitted to ``PyPI`` and others can easily set it up with ``pip``."
#~ msgstr ""
#~ "包管理器 (pip)。开发好的 Taichi 应用可以被轻松地上传到 ``PyPI`` 并被其他人"
#~ "轻松地用 ``pip`` 安装。"

#~ msgid ""
#~ "Existing packages. Interacting with other python components (e.g. "
#~ "``matplotlib`` and ``numpy``) is just trivial."
#~ msgstr ""
#~ "现成的包。和其它 python 库（例如 ``matplotlib`` 和 ``numpy``）一起使用也是"
#~ "轻而易举的。"

#~ msgid ""
#~ "The built-in AST manipulation tools in ``python`` allow us to do magical "
#~ "things, as long as the kernel body can be parsed by the Python parser."
#~ msgstr ""
#~ "只要内核主体能够被 Python 解释器解析，``python`` 内置的 AST（抽象语法树）"
#~ "处理工具就允许我们完成一些神奇的事情。"

#~ msgid "However, this design has drawbacks as well:"
#~ msgstr "然而，这一设计同时也存在着这些缺点："

#~ msgid ""
#~ "Taichi kernels must parse-able by Python parsers. This means Taichi "
#~ "syntax cannot go beyond Python syntax."
#~ msgstr ""
#~ "Taichi 内核必须是可以被 Python 解释器解析的。这意味着 Taichi 语法无法脱离 "
#~ "Python 的语法。"

#~ msgid ""
#~ "For example, indexing is always needed when accessing elements in Taichi "
#~ "tensors, even if the tensor is 0D. Use ``x[None] = 123`` to set the value "
#~ "in ``x`` if ``x`` is 0D. This is because ``x = 123`` will set ``x`` "
#~ "itself (instead of its containing value) to be the constant ``123`` in "
#~ "python syntax, and, unfortunately, we cannot modify this behavior."
#~ msgstr ""
#~ "例如，获取 Taichi 张量中的元素总是需要下标，即使是 0 维张量。需要用 "
#~ "``x[None] = 123`` 来给 0 维的 ``x`` 赋予值。这是因为在 python 语法中 ``x "
#~ "= 123`` 会设置 ``x`` 本身（而非其包含的值）为恒量 ``123``，而不幸的是我们"
#~ "没法改变解释器的这个行为。"

#~ msgid ""
#~ "Python has relatively low performance. This can cause a performance issue "
#~ "when initializing large Taichi tensors with pure python scripts. A Taichi "
#~ "kernel should be used to initialize a huge tensor."
#~ msgstr ""
#~ "Python 的性能相对较低。比如仅靠 Python 作用域来初始化很大的张量时，会导致"
#~ "性能问题。所以较大张量的初始化应该放在 Taichi 内核中。"
